library ieee;
use ieee.std_logic_1164.all;

entity aula7 is
  generic ( 
    larguraDados : natural := 8;
    enderecoRom  : natural := 9;
    DataRom      : natural := 13;
    EnderecoRam  : natural := 8;
    simulacao    : boolean := TRUE
  );
  port (
    CLOCK_50         : in  std_logic;
	 FPGA_RESET_N     : in  std_logic; 
    KEY              : in  std_logic_vector(3 downto 0);
	 SW               : in std_logic_vector(9 downto 0);
    --palavra_controle : out std_logic_vector(11 downto 0);
    PC_OUT           : out std_logic_vector(enderecoRom-1 downto 0);
    LEDR             : out std_logic_vector(9 downto 0);
	 HEX0, HEX1, HEX2, HEX3, HEX4, HEX5      : out std_logic_vector(6 downto 0)
	 
  );
end entity;

architecture arquitetura of aula7 is

  -- Sinais de conexão
  signal cpu_ROMADDRESS, cpu_DATAADDRESS      : std_logic_vector(8 downto 0);
  signal cpu_INSTRUCAOIN  : std_logic_vector(14 downto 0);
  signal cpu_DATAIN       : std_logic_vector(7 downto 0);
  signal cpu_DATAOUT      : std_logic_vector(7 downto 0);
  --signal HEX0,HEX1,HEX2,HEX3,HEX4,HEX5 : std_logic_vector (6 downto 0);
  signal SAIDA_DECODERBLOCO : std_logic_vector(7 downto 0);
  signal SAIDA_DECODERENDERECO : std_logic_vector(7 downto 0);
  signal reg_led : std_logic_vector(7 downto 0);
  signal en_8leds, en_led8, en_led9 : std_logic;
  signal ff_led8, ff_led9 : std_logic;
  signal cpu_RD, cpu_WR : std_logic;
  signal CLK : std_logic;
  signal leituraUmSegundo: std_logic;
  signal HAB_HEX0,HAB_HEX1,HAB_HEX2,HAB_HEX3,HAB_HEX4,HAB_HEX5 : std_logic;
  signal HAB_KEY0,HAB_KEY1,HAB_KEY2,HAB_KEY3,HAB_FPGARESET,HAB_CLOCK : std_logic;
  signal HAB_SW8s, HAB_SW8, HAB_SW9 : std_logic;
  signal SAIDA_KEY0, SAIDA_KEY1,SAIDA_KEY3,SAIDA_CLOCK : std_logic; -- MELHORAR NOME, USEI ELE PARA DEBOUNCE E MEMORIZACAO
  signal limpaLeiturakey0,limpaLeiturakey1,limpaLeiturakey3,limpaLeituraclock : std_logic;
  signal seletor_clock : std_logic_vector(1 downto 0);
  signal clk_1hz, clk_2hz, clk_0_5hz, clk_0_25hz : std_logic;

  
begin

  -- Lógica de habilitação dos LEDs
en_8leds <= SAIDA_DECODERBLOCO(4) and cpu_WR and SAIDA_DECODERENDERECO(0) and not(cpu_DATAADDRESS(5));
en_led8  <= SAIDA_DECODERBLOCO(4) and cpu_WR and SAIDA_DECODERENDERECO(1) and not(cpu_DATAADDRESS(5));
en_led9  <= SAIDA_DECODERBLOCO(4) and cpu_WR and SAIDA_DECODERENDERECO(2) and not(cpu_DATAADDRESS(5));
  -- Lógica de habilitação dos Display
hab_hex0  <= SAIDA_DECODERBLOCO(4) and cpu_WR and SAIDA_DECODERENDERECO(0) and (cpu_DATAADDRESS(5));
hab_hex1  <= SAIDA_DECODERBLOCO(4) and cpu_WR and SAIDA_DECODERENDERECO(1) and (cpu_DATAADDRESS(5));
hab_hex2  <= SAIDA_DECODERBLOCO(4) and cpu_WR and SAIDA_DECODERENDERECO(2) and (cpu_DATAADDRESS(5));
hab_hex3  <= SAIDA_DECODERBLOCO(4) and cpu_WR and SAIDA_DECODERENDERECO(3) and (cpu_DATAADDRESS(5));
hab_hex4  <= SAIDA_DECODERBLOCO(4) and cpu_WR and SAIDA_DECODERENDERECO(4) and (cpu_DATAADDRESS(5));
hab_hex5  <= SAIDA_DECODERBLOCO(4) and cpu_WR and SAIDA_DECODERENDERECO(5) and (cpu_DATAADDRESS(5));
  -- Lógica de habilitação das keys
hab_key0  <= SAIDA_DECODERBLOCO(5) and cpu_RD and SAIDA_DECODERENDERECO(0) and (cpu_DATAADDRESS(5));
hab_key1  <= SAIDA_DECODERBLOCO(5) and cpu_RD and SAIDA_DECODERENDERECO(1) and (cpu_DATAADDRESS(5));
hab_key2  <= SAIDA_DECODERBLOCO(5) and cpu_RD and SAIDA_DECODERENDERECO(2) and (cpu_DATAADDRESS(5));
hab_key3  <= SAIDA_DECODERBLOCO(5) and cpu_RD and SAIDA_DECODERENDERECO(3) and (cpu_DATAADDRESS(5));
  -- Lógica de habilitação dos FPGA RESET
hab_fpgareset  <= SAIDA_DECODERBLOCO(5) and cpu_RD and SAIDA_DECODERENDERECO(4) and (cpu_DATAADDRESS(5));
hab_clock  <= SAIDA_DECODERBLOCO(5) and cpu_RD and SAIDA_DECODERENDERECO(5) and (cpu_DATAADDRESS(5));

  -- Lógica de habilitação dos SW
hab_sw8s  <= SAIDA_DECODERBLOCO(5) and cpu_RD and SAIDA_DECODERENDERECO(0) and not(cpu_DATAADDRESS(5));
hab_sw8  <= SAIDA_DECODERBLOCO(5) and cpu_RD and SAIDA_DECODERENDERECO(1) and not(cpu_DATAADDRESS(5));
hab_sw9  <= SAIDA_DECODERBLOCO(5) and cpu_RD and SAIDA_DECODERENDERECO(2) and not(cpu_DATAADDRESS(5));

limpaLeiturakey0 <= cpu_DATAADDRESS(0) and cpu_DATAADDRESS(1) and cpu_DATAADDRESS(2) and cpu_DATAADDRESS(3) and cpu_DATAADDRESS(4) and 
	cpu_DATAADDRESS(5) and cpu_DATAADDRESS(6) and cpu_DATAADDRESS(7) and cpu_DATAADDRESS(8) and cpu_WR;
limpaLeiturakey1 <= not(cpu_DATAADDRESS(0)) and cpu_DATAADDRESS(1) and cpu_DATAADDRESS(2) and cpu_DATAADDRESS(3) and cpu_DATAADDRESS(4) and 
	cpu_DATAADDRESS(5) and cpu_DATAADDRESS(6) and cpu_DATAADDRESS(7) and cpu_DATAADDRESS(8) and cpu_WR;
	
limpaLeiturakey3 <= not(cpu_DATAADDRESS(0)) and not(cpu_DATAADDRESS(1)) and cpu_DATAADDRESS(2) and cpu_DATAADDRESS(3) and cpu_DATAADDRESS(4) and 
	cpu_DATAADDRESS(5) and cpu_DATAADDRESS(6) and cpu_DATAADDRESS(7) and cpu_DATAADDRESS(8) and cpu_WR;

limpaLeituraclock <= cpu_DATAADDRESS(0) and not(cpu_DATAADDRESS(1)) and cpu_DATAADDRESS(2) and cpu_DATAADDRESS(3) and cpu_DATAADDRESS(4) and 
	cpu_DATAADDRESS(5) and cpu_DATAADDRESS(6) and cpu_DATAADDRESS(7) and cpu_DATAADDRESS(8) and cpu_WR;

	
seletor_clock <= SW(8 downto 7);

  -- Gerador de clock
  gravar: if simulacao generate
    CLK <= CLOCK_50	;
  else generate
    detectorSub0: entity work.edgeDetector(bordaSubida)
      port map (clk => CLOCK_50, entrada =>not KEY(0), saida => CLK);
  end generate;
  
  
  
 -- divisor : entity work.divisorGenerico
 --           generic map (divisor => 25000000)   -- divide por 50M.
 --           port map (clk => CLOCK_50 , saida_clk => leituraUmSegundo);
				
  div1Hz: entity work.divisorGenerico
    generic map (divisor => 25000000)
    port map (clk => CLOCK_50, saida_clk => clk_1hz);

  div2Hz: entity work.divisorGenerico
    generic map (divisor => 250000)
    port map (clk => CLOCK_50, saida_clk => clk_2hz);

  div0_5Hz: entity work.divisorGenerico
    generic map (divisor => 25000)
    port map (clk => CLOCK_50, saida_clk => clk_0_5hz);

  div0_25Hz: entity work.divisorGenerico
    generic map (divisor => 2500)
    port map (clk => CLOCK_50, saida_clk => clk_0_25hz);

	 
	 
  -- Instancia CPU (usando CLK)
  CPU1 : entity work.CPU
    port map(
      CLK      => CLK,         -- usar CLK gerado
      ROM_Address     => cpu_ROMADDRESS,
		Data_Address     => cpu_DATAADDRESS,
      Instruction_IN    => cpu_INSTRUCAOIN,
      Data_IN  => cpu_DATAIN,
      Data_OUT => cpu_DATAOUT,
      HabilitaleituraRAM       => cpu_RD,
      HabilitaescritaRAM       => cpu_WR
    );

  -- Instancia ROM
  ROM1 : entity work.memoriaROM
    port map(
      Endereco => cpu_ROMADDRESS,   -- 9 bits
      Dado     => cpu_INSTRUCAOIN
    );

  -- Instancia RAM
  RAM1 : entity work.memoriaRAM
    port map(
      addr     => cpu_DATAADDRESS(5 downto 0),
      we       => cpu_WR,
      re       => cpu_RD,
      habilita => SAIDA_DECODERBLOCO(0),  -- se RAM estiver no bloco 0, esta estranho.
      dado_in  => cpu_DATAOUT,
      dado_out => cpu_DATAIN,
      clk      => CLK
    );

  -- Decodificador de Blocos
  DECODERBLOCO: entity work.decoder3x8
    port map (
      addr => cpu_DATAADDRESS(8 downto 6),
      y    => SAIDA_DECODERBLOCO
    );
			
  DECODEREND: entity work.decoder3x8
    port map (
      addr => cpu_DATAADDRESS(2 downto 0),
      y    => SAIDA_DECODERENDERECO
    );
	 
   FLIPFLOPLED8: entity work.flipFlopCEQ
	    port map (
      clk     => CLK,
      rst     => '0',
      enable => en_led8,
      din => CPU_DATAOUT(0),
		dout => LEDR(8));
		
    FLIPFLOPLED9: entity work.flipFlopCEQ
	    port map (
      clk     => CLK,
      rst     => '0',
      enable => en_led9,
      din => CPU_DATAOUT(0),
		dout => LEDR(9));
		
   REGISTRADORLEDS : entity work.registradorGenerico   generic map (larguraDados => larguraDados)
          port map (DIN => CPU_DATAOUT,
						  DOUT => LEDR(7 downto 0),
						  ENABLE => en_8leds, 
						  CLK => CLK,
						  RST => '0');
						  
	Display_Unit0: entity work.Display_Unit
			 port map(
			 data_in => cpu_DATAOUT(3 downto 0),
			 clk => CLK,
			 habilita=>hab_hex0,
			 data_out=>HEX0
			 );
	Display_Unit1: entity work.Display_Unit
			 port map(
			 data_in => cpu_DATAOUT(3 downto 0),
			 clk => CLK,
			 habilita=>hab_hex1,
			 data_out=>HEX1
			 );
	Display_Unit2: entity work.Display_Unit
			 port map(
			 data_in => cpu_DATAOUT(3 downto 0),
			 clk => CLK,
			 habilita=>hab_hex2,
			 data_out=>HEX2
			 );
	Display_Unit3: entity work.Display_Unit
			 port map(
			 data_in => cpu_DATAOUT(3 downto 0),
			 clk => CLK,
			 habilita=>hab_hex3,
			 data_out=>HEX3
			 );
	Display_Unit4: entity work.Display_Unit
			 port map(
			 data_in => cpu_DATAOUT(3 downto 0),
			 clk => CLK,
			 habilita=>hab_hex4,
			 data_out=>HEX4
			 );
	Display_Unit5: entity work.Display_Unit
			 port map(
			 data_in => cpu_DATAOUT(3 downto 0),
			 clk => CLK,
			 habilita=>hab_hex5,
			 data_out=>HEX5
			 );
			 
	BUFFER3STATE_8SWs: entity work.buffer_3_state_8portas
	port map(
			 entrada => SW(7 downto 0),
          habilita => hab_sw8s,
          saida => cpu_datain
			 );
	BUFFER3STATE_SW8: entity work.buffer_3_state_1porta
	port map(
			 entrada => SW(8),
          habilita => hab_sw8,
          saida => cpu_datain(0)
			 );
	BUFFER3STATE_SW9: entity work.buffer_3_state_1porta
	port map(
			 entrada => SW(9),
          habilita => hab_sw9,
          saida => cpu_datain(0)
			 );
			 
	BUFFER3STATE_CLOCK: entity work.buffer_3_state_1porta
	port map(
			 entrada => saida_clock,
          habilita => hab_clock,
          saida => cpu_datain(0)
			 );
	BUFFER3STATE_KEY0: entity work.buffer_3_state_1porta
	port map(
			 entrada => saida_key0,
          habilita => hab_key0,
          saida => cpu_datain(0)
			 );
	BUFFER3STATE_KEY1: entity work.buffer_3_state_1porta
	port map(
			 entrada => saida_key1,
          habilita => hab_key1,
          saida => cpu_datain(0)
			 );
	BUFFER3STATE_KEY2: entity work.buffer_3_state_1porta
	port map(
			 entrada => KEY(2),
          habilita => hab_key2,
          saida => cpu_datain(0)
			 );
	BUFFER3STATE_KEY3: entity work.buffer_3_state_1porta
	port map(
			 entrada => SAIDA_KEY3,
          habilita => hab_key3,
          saida => cpu_datain(0)
			 );
	BUFFER3STATE_FPGARESET: entity work.buffer_3_state_1porta
	port map(
			 entrada => FPGA_RESET_N,
          habilita => hab_fpgareset,
          saida => cpu_datain(0)
			 );
	
	tratamentoKey0: entity work.keyTratamento
	port map(
				data_in => not key(0),
				clk     => CLK,
				rst     => limpaLeiturakey0,
				data_out => saida_key0
			 );
	tratamentoKey1: entity work.keyTratamento
	port map(
				data_in => not(key(1)),
				clk     => CLK,
				rst     => limpaLeiturakey1,
				data_out => saida_key1
			 );
			 
 tratamentoClock: entity work.keyTratamento
	port map(
				data_in => leituraUmSegundo,
				clk     => CLK,
				rst     => limpaLeituraclock,
				data_out => saida_clock
			 );
			 
	tratamentoKey3: entity work.keyTratamento
	port map(
				data_in => not key(3),
				clk     => CLK,
				rst     => limpaLeiturakey3,
				data_out => saida_key3
			 );
	
	
  PC_OUT <= cpu_ROMADDRESS;

  with seletor_clock select
  leituraUmSegundo <= clk_1hz    when "00",
                      clk_2hz    when "01",
                      clk_0_5hz  when "10",
                      clk_0_25hz when others;

end architecture;